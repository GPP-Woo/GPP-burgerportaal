using Microsoft.AspNetCore.StaticFiles;
using Microsoft.Net.Http.Headers;

namespace Microsoft.AspNetCore.Builder;

public static class StaticFileCacheHeaders
{
    private const int DurationInSeconds = 60 * 60 * 24 * 100;

    private static readonly CacheControlHeaderValue s_longCache = new()
    {
        Public = true,
        MaxAge = TimeSpan.FromSeconds(DurationInSeconds),
    };

    private static readonly CacheControlHeaderValue s_noCache = new()
    {
        NoCache = true,
    };

    private static readonly CacheControlHeaderValue s_noCacheNoStore = new()
    {
        NoCache = true,
        NoStore = true
    };

    private static readonly StaticFileOptions s_staticFileOptions = new()
    {
        OnPrepareResponse = SetCacheHeader,
    };

    public static IApplicationBuilder UseOdbpStaticFiles(this IApplicationBuilder app) => app.UseStaticFiles(s_staticFileOptions);

    public static IEndpointConventionBuilder MapFallbackToIndexHtml(this IEndpointRouteBuilder builder) => builder
        .MapFallbackToFile("index.html", s_staticFileOptions).AllowAnonymous();

    private static void SetCacheHeader(this StaticFileResponseContext ctx)
    {
        var headers = ctx.Context.Response.GetTypedHeaders();
        headers.CacheControl = ctx.GetCacheControlHeaderValue();
    }

    private static CacheControlHeaderValue GetCacheControlHeaderValue(this StaticFileResponseContext ctx)
    {
        var path = ctx.Context.Request.Path.Value ?? "";
        var parent = Path.GetDirectoryName(path.AsSpan());
        // don't cache html files and also ignore etags,
        // because security headers might change,
        // and in that case the etag doesn't change with it
        if (ctx.File.Name.EndsWith(".html")) return s_noCacheNoStore;
        // if the is in the assets folder, it is generated by vite and has a content hash, so we can cache it indefinitely
        // we tried to detect this with a regex but it was hit and miss
        else if (parent.EndsWith("assets")) return s_longCache;
        // otherwise we shouldn't cache, but we can still use etags
        return s_noCache;
    }
}
